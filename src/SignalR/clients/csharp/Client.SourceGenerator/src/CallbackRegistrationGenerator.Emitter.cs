using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerator
{
    internal partial class CallbackRegistrationGenerator
    {
        public class Emitter
        {
            private readonly GeneratorExecutionContext _context;
            private readonly SourceGenerationSpec _spec;

            public Emitter(GeneratorExecutionContext context, SourceGenerationSpec spec)
            {
                _context = context;
                _spec = spec;
            }

            public void Emit()
            {
                EmitExtensions();
                foreach (var typeSpec in _spec.Types)
                {
                    EmitRegistrationMethod(typeSpec);
                }
            }

            private void EmitExtensions()
            {
                var registerProviderBody = new StringBuilder();

                foreach (var typeSpec in _spec.Types)
                {
                    var methodName = $"register{typeSpec.TypeName}";
                    var fqtn = typeSpec.FullyQualifiedTypeName;
                    registerProviderBody.AppendLine($@"
            if(typeof(T) == typeof({fqtn})) return (System.IDisposable) new CallbackProviderRegistration({methodName}(conn, ({fqtn}) provider));");
                }

                var extensions = $@"// Generated by Microsoft.AspNetCore.Client.SourceGenerator
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client
{{
    public static partial class HubConnectionExtensionsGenerated
    {{
        public static System.IDisposable RegisterCallbackProvider<T>(this IHubConnection conn, T provider)
        {{
{registerProviderBody.ToString()}
            throw new System.ArgumentException(nameof(T));
        }}

        private sealed class CallbackProviderRegistration : System.IDisposable
        {{
            private System.IDisposable[] registrations;
            public CallbackProviderRegistration(params System.IDisposable[] registrations)
            {{
                this.registrations = registrations;
            }}

            public void Dispose()
            {{
                if(this.registrations is null) return;
                System.Collections.Generic.List<System.Exception> exceptions = null;
                foreach(var registration in this.registrations)
                {{
                    try
                    {{
                        registration.Dispose();
                    }}
                    catch (System.Exception exc)
                    {{
                        if(exceptions is null) exceptions = new ();
                        exceptions.Add(exc);
                    }}
                }}
                this.registrations = null;
                if(exceptions is not null) throw new System.AggregateException(exceptions);
            }}
        }}
    }}
}}";

                _context.AddSource("CallbackRegistration.g.cs", SourceText.From(extensions.ToString(), Encoding.UTF8));
            }

            private void EmitRegistrationMethod(TypeSpec typeSpec)
            {
                var registrationMethodBody = new StringBuilder($@"
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client
{{
    public static partial class HubConnectionExtensionsGenerated
    {{
        private static System.IDisposable[] register{typeSpec.TypeName}(IHubConnection conn, {typeSpec.FullyQualifiedTypeName} provider)
        {{
            var registrations = new System.IDisposable[{typeSpec.Methods.Count}];");

                // Generate each of the methods
                var i = 0;
                foreach (var member in typeSpec.Methods)
                {
                    var genericArgs = new StringBuilder();
                    var lambaParams = new StringBuilder();

                    // Populate call with its parameters
                    var first = true;
                    foreach (var parameter in member.Arguments)
                    {
                        if (first)
                        {
                            genericArgs.Append('<');
                            lambaParams.Append('(');
                        }
                        else
                        {
                            genericArgs.Append(", ");
                            lambaParams.Append(", ");
                        }

                        first = false;
                        genericArgs.Append($"{parameter.FullyQualifiedTypeName}");
                        lambaParams.Append($"{parameter.Name}");
                    }

                    if (!first)
                    {
                        genericArgs.Append('>');
                        lambaParams.Append(')');
                    }
                    else
                    {
                        lambaParams.Append("()");
                    }


                    var lambda = $"{lambaParams} => provider.{member.Name}{lambaParams}";
                    var call = $"conn.On{genericArgs}(\"{member.Name}\", {lambda})";

                    registrationMethodBody.AppendLine($@"
            registrations[{i}] = {call};");
                    ++i;
                }
                registrationMethodBody.AppendLine(@"
            return registrations;
        }
    }
}");

                _context.AddSource($"CallbackRegistration.{typeSpec.TypeName}.g.cs", SourceText.From(registrationMethodBody.ToString(), Encoding.UTF8));
            }
        }
    }
}
