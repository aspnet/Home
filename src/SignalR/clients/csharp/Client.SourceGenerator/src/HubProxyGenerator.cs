using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerator
{
    [Generator]
    internal class HubProxyGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var getProxyBody = new StringBuilder(@"// Generated by Microsoft.AspNetCore.Client.SourceGenerator
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client
{
    public static partial class HubConnectionExtensionsGenerated
    {
        public static THub GetProxy<THub>(this IHubConnection conn)
        {");
            var getProxyFooter = @"
            throw new System.ArgumentException(nameof(THub));
        }
    }
}";

            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            {
                // nothing to do yet
                getProxyBody.Append(getProxyFooter);
                context.AddSource("GeneratedBy" + nameof(HubProxyGenerator),
                    SourceText.From(getProxyBody.ToString(), Encoding.UTF8));
                return;
            }

            var hubSymbols = new Dictionary<string, (ITypeSymbol, MemberAccessExpressionSyntax)>();
            var iHubConnectionType =
                context.Compilation.GetTypeByMetadataName("Microsoft.AspNetCore.SignalR.Client.IHubConnection");

            // Go thru candidates and filter
            foreach(var (memberAccess, proxyType) in receiver.Candidates)
            {
                var expressionModel = context.Compilation.GetSemanticModel(memberAccess.Expression.SyntaxTree);
                var typeInfo = expressionModel.GetTypeInfo(memberAccess.Expression);

                // Filter based on receiver symbol
                if(!SymbolEqualityComparer.Default.Equals(typeInfo.Type, iHubConnectionType) &&
                   (typeInfo.Type.AllInterfaces.IsDefaultOrEmpty ||
                    !typeInfo.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, iHubConnectionType))))
                {
                    // Member access is not acting on IHubConnection or a type implementing it; as such we will skip
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "XX0001",
                            "Non-void method return type",
                            "Method {0}. All methods must return void.",
                            "yeet",
                            DiagnosticSeverity.Warning,
                            true), memberAccess.GetLocation(), typeInfo.Type.Name));
                    continue;
                }

                // Filter based on argument symbol
                var argumentModel = context.Compilation.GetSemanticModel(proxyType.SyntaxTree);
                if (argumentModel.GetSymbolInfo(proxyType).Symbol is not ITypeSymbol {IsAbstract: true} symbol)
                {
                    // T in GetProxy<T> must be an interface
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "XX0002",
                            "Non-interface generic type argument",
                            "'GetProxy<THub>' only accepts interfaces. '{0}' is not an interface.",
                            "SignalR.Client.SourceGenerator",
                            DiagnosticSeverity.Error,
                            true), memberAccess.GetLocation(), proxyType.ToString()));
                    continue;
                }

                // Receiver is a IHubConnection and argument is abstract so save argument symbol for generation
                hubSymbols[symbol.Name] = (symbol, memberAccess);
            }

            // Generate proxy classes for all the hub interfaces detected previously
            var proxiesBody = new StringBuilder(@"
namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerated
{");

            foreach (var (hubSymbol, memberAccess) in hubSymbols.Values)
            {
                var typeName = $"Generated{hubSymbol.Name}";
                proxiesBody.AppendLine($@"
    public sealed class {typeName} : {hubSymbol.ToString()}
    {{
        private readonly Microsoft.AspNetCore.SignalR.Client.IHubConnection conn;
        public {typeName}(Microsoft.AspNetCore.SignalR.Client.IHubConnection connection)
        {{
            this.conn = connection;
        }}");

                var members = hubSymbol.GetMembers()
                    .Where(member => member.Kind == SymbolKind.Method)
                    .Select(member => (IMethodSymbol) member)
                    .Concat(hubSymbol.AllInterfaces.SelectMany(x => x
                        .GetMembers()
                        .Where(member => member.Kind == SymbolKind.Method)
                        .Select(member => (IMethodSymbol) member)));

                // Generate each of the methods
                foreach (var member in members)
                {
                    var signature = new StringBuilder($"public {member.ReturnType.ToString()} {member.Name}(");
                    var first = true;

                    var callArgs = new StringBuilder("");

                    // Populate signature with its parameters
                    foreach (var parameter in member.Parameters)
                    {
                        if (!first)
                        {
                            signature.Append(", ");
                        }

                        first = false;
                        signature.Append($"{parameter.Type.ToString()} {parameter.Name}");

                        callArgs.Append($", {parameter.Name}");
                    }

                    signature.Append(')');


                    var specificCall = getSpecificCall(member);
                    string call;
                    if (specificCall is null)
                    {
                        call = "throw new System.NotSupportedException();";
                        context.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "XX0003",
                                "Not supported method",
                                "'{0}.{1}' has an unsupported signature for proxy generation.",
                                "SignalR.Client.SourceGenerator",
                                DiagnosticSeverity.Warning,
                                true), memberAccess.GetLocation(), hubSymbol.Name, member.Name));
                        // Location for the diagnostic report is the GetProxy call site since there is no guarantee that
                        //  the method definition lays within source of current project.
                    }
                    else
                    {
                        call = $"return this.conn.{specificCall}(\"{member.Name}\"{callArgs.ToString()});";
                    }

                    proxiesBody.AppendLine($@"
        {signature}
        {{
            {call}
        }}");
                }

                proxiesBody.AppendLine(@"
    }");
            }

            proxiesBody.AppendLine(@"
}");

            // Populate GetProxy<T> with calls to appropriate proxy constructors
            foreach (var (hubSymbol, memberAccess) in hubSymbols.Values)
            {
                var typeName = $"Microsoft.AspNetCore.SignalR.Client.SourceGenerated.Generated{hubSymbol.Name}";
                getProxyBody.AppendLine($@"
            if(typeof(THub) == typeof({hubSymbol})) return (THub) ({hubSymbol}) new {typeName}(conn);");
            }

            getProxyBody.AppendLine(getProxyFooter);
            getProxyBody.AppendLine(proxiesBody.ToString());

            context.AddSource("GeneratedBy" + nameof(HubProxyGenerator),
                SourceText.From(getProxyBody.ToString(), Encoding.UTF8));
        }

        private string? getSpecificCall(IMethodSymbol member)
        {
            if (member.ReturnType is INamedTypeSymbol { Arity: 1, Name: "Task"} a
                && a.TypeArguments[0] is INamedTypeSymbol { Arity: 1, Name: "ChannelReader"} b)
            {
                return $"StreamAsChannelAsync<{b.TypeArguments[0]}>";
            }

            if (member.ReturnType is INamedTypeSymbol { Arity: 1, Name: "IAsyncEnumerable"} c)
            {
                return $"StreamAsync<{c.TypeArguments[0]}>";
            }

            if (!member.ReturnType.ToString().StartsWith("System.Threading.Tasks.Task", StringComparison.Ordinal))
            {
                return null;
            }

            if (member.Parameters.Any(symbol =>
                symbol.Type.ToString().Contains("ChannelReader<")
                || symbol.Type.ToString().Contains("IAsyncEnumerable<")))
            {
                return "SendAsync";
            }

            if (member.ReturnType is INamedTypeSymbol {Arity: 1, Name: "Task"} d)
            {
                return $"InvokeAsync<{d.TypeArguments[0]}>";
            }

            if (member.ReturnType is INamedTypeSymbol {Arity: 0, Name: "Task"})
            {
                return "InvokeAsync";
            }

            return null;
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<(MemberAccessExpressionSyntax, TypeSyntax)> Candidates { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MemberAccessExpressionSyntax
                {
                    Name: GenericNameSyntax
                    {
                        TypeArgumentList:
                        {
                            Arguments: { Count: 1 } arguments
                        },
                        Identifier:
                        {
                            ValueText: "GetProxy"
                        }
                    }
                } getProxyCall)
                {
                    Candidates.Add((getProxyCall, arguments[0]));
                }
            }
        }
    }
}
